(*Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal 
and D = |Pk − Pj| is minimised; what is the value of D?*)


// IDEAS //
// 1. scan the sequence by the window and increase the window until you get a hit
// 2. use floats

let pentagonalnumbers = Seq.unfold (fun x-> Some(((3.0*x-1.0)*x)/2.0,x+1.0)) 1.0 |> Seq.cache

let ispentagonal x = if x<1.0 then false else ((sqrt (24.0* x  + 1.0) + 1.0) / 6.0) % 1.0 = 0.0

let checkforproperty (number : float) (listofnumbers : float list) = 
    let rec checknumberagainstlist = function
        | [] -> (number,-1.0)
        | head::tail when tail=[] -> (number,-1.0)
        | head::tail when number+head<(List.head tail) -> (number,-1.0)
        | head::tail when (ispentagonal (number+head)  && ispentagonal (head-number)) -> (number,head)
        | head::tail -> checknumberagainstlist tail
    checknumberagainstlist listofnumbers

let rec checkforproperty2 thepentagonnumbers = 
    if List.length thepentagonnumbers < 2 then []
    else
        let head = (List.head thepentagonnumbers)
        let tail = (List.tail thepentagonnumbers)
        let temp = checkforproperty head tail
        if snd temp <> -1.0 then [temp] else checkforproperty2 tail

let stopWatch = System.Diagnostics.Stopwatch.StartNew()
let answer = 
    checkforproperty2 (pentagonalnumbers |> Seq.take 10000 |> Seq.toList)
    |> (fun [(a:float,b:float)] -> b-a)
stopWatch.Stop()
printfn "%f" stopWatch.Elapsed.TotalMilliseconds

// Lessons learned
// Recursion is fun
// Recursion is a little confusing
// The checkforproperty function is a little bit of a rickshaw

///////////////////////////////////////////////////////////////////////////////////////////////////////////
// SCRATCH SCRATCH SCRATCH SCRATCH SCRATCH SCRATCH SCRATCH SCRATCH SCRATCH SCRATCH SCRATCH SCRATCH SCRATCH 
///////////////////////////////////////////////////////////////////////////////////////////////////////////


//let firstdifferences = Seq.unfold (fun x -> Some(3.0*x+1.0,x+1.0)) 1.0 |> Seq.cache

let ndifference index n = ((index + n) * (3.0*(index + n ) - 1.0) / 2.0) - (index * (3.0*index - 1.0) / 2.0)

let pentagonaltuples = Seq.unfold (fun (x,_) -> Some((x,x*(3.0*x-1.0)/2.0),(x+1.0,0.0))) (1.0,1.0) |> Seq.cache

let difference (index : int) (step : int) = //(x+n,((x + n) * (3.0*(x + n ) - 1.0) / 2.0) - (x * (3.0*x - 1.0) / 2.0))
    let x = float index
    let n = float step
    let here = (3.0*x*x-x)/2.0
    let there = (3.0*n*n+6.0*n*x-n+3.0*x*x-x)/2.0
    let difference = here-there
    ((x, here), (x+n,there), difference, ispentagonal difference)


let getv x = (3.0*x*x-x)/2.0
let getwindow x windowsize = [x-windowsize .. x+windowsize] |> List.map getv
let getwindow value windowsize = [value-windowsize .. value+windowsize] |> List.filter ispentagonal |> List.filter (fun x-> x<> value)
let hasproperty value windowsize = getwindow value windowsize |> List.filter (fun x->ispentagonal(value+x)) |> List.filter (fun x-> ispentagonal (x-value))

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// trying to just find one that has the property
let pentagonlist = pentagonalnumbers|>Seq.take 1000 |> Seq.toList
let checkforproperty (listofnumbers : float list) (number : float) = 
    let rec checknumberagainstlist = function
        | [] -> (number,-1.0)
        | head::tail when tail=[] -> (number,-1.0)
        | head::tail when number+head<(List.head tail) -> (number,-1.0)
        | head::tail when (ispentagonal (number+head)  )-> (number,head)//&& ispentagonal (head-number)) -> (number,head)
        | head::tail -> checknumberagainstlist tail
    checknumberagainstlist listofnumbers

let rec checkforproperty2 thepentagonnumbers = 
    match thepentagonnumbers with
        | [] -> []
        | head::tail when checkforproperty tail head |> snd <> -1.0 -> head :: checkforproperty2 tail
        | head::tail -> checkforproperty2 tail
    (*
    let rec loop input = 
        let temp = checkforproperty input (List.head input)
        match temp with
        | x when snd temp = -1.0 -> 
        | x when snd temp <> -1.0 -> [temp]
    loop thepentagonnumbers
    // pass List.tail thepentagonnumbers
    *)

let numberswithproperty = 
    pentagonlist
    |> List.map (checkforproperty pentagonlist)
    |> List.filter (fun (a,b) -> b <> -1.0)
    |> List.filter (fun (a,b) -> a<>b)





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
let naturals = Seq.unfold (fun x-> Some(x,x+1.0)) 1.0 |> Seq.cache
let getallnumberswithin windowsize = naturals |> Seq.map getv |> Seq.takeWhile (fun x)
// need a sequence of cum sum of differences
let cumdiff = Seq.unfold (fun (x,diff) -> 
    let difference = 3.0*x+1.0
    Some(difference,(x+1.0,difference))) (1.0, 0.0) |> Seq.cache
// ??? How do we actually need the windows to work?
let cumdiff =  Seq.scan (fun acc elem -> acc + 3.0*elem+1.0) 0.0 naturals |> Seq.cache

// This should be the form for expanding the window and finding the correct matches
let rec findwindow number = 
    let algorithmoutput = algorithmforfindingwindows number
    if wehaveahit algorithm then algorithmoutput
    else findwindow number + 1
findwindow 1
    
//////////////////
let sumSeq sequence1 = Seq.scan (fun acc elem -> acc + elem) 0 sequence1
Seq.init 10 (fun index -> index * index)
|> sumSeq
|> Seq.toList
|> printfn "The sum of the elements is %d."
///////////////////////////////


let firstdifferences = pentagonalnumbers |> Seq.map ndifference
// This returns a tuple value with the index jumped to and the difference away from sequence indices
let difference (x,v) n = (x+n,((x + n) * (3*(x + n ) - 1) / 2) - (x * (3*x - 1) / 2))
